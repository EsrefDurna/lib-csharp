// <auto-generated />
// AUTO-GENERATED FILE - DO NOT MODIFY
// Generated from roundtrip.babel
// Roundtrip all types

using System;
using System.Collections.Generic;
using System.Text;
using BabelRpc;

namespace BabelRpc.Demo
{

	/// <summary>
	///  Meat or potatoes
	/// </summary>
	[System.CodeDom.Compiler.GeneratedCode("Babel", "")]
	public enum Type
	{
		MEAT = 1,
		POTATOES = 2
	}

	/// <summary>
	///  Some string you might use someday
	/// </summary>
	[System.CodeDom.Compiler.GeneratedCode("Babel", "")]
	public sealed class Strings
	{
		public const char CHAR = 'A';
		public const string STRING = "All your base are belong to us.";
	}

	/// <summary>
	///  A struct that feels empty inside
	/// </summary>
	public abstract class Empty : IBabelModel
	{
		/// <summary>
		/// Default constructor
		/// </summary>
		public Empty()
		{ 
		}

		public override string ToString()
		{
			var ser = new BabelJsonSerializer();
			using(var strm = (System.IO.MemoryStream)ser.Serialize(this))
			{
				return (new UTF8Encoding(false)).GetString(strm.ToArray());
			}
		}
		#region IBabelModel
		public virtual void RunOnChildren<T>(BabelModelAction<T> method, T auxData, bool runOnAll = true)
		{
			if(method == null) throw new ArgumentNullException("method");

		}

		public virtual bool RunOnChild<T>(string name, BabelModelAction<T> method, T auxData)
		{
			if(method == null) throw new ArgumentNullException("method");
			switch(name)
			{
				default: return false;
			}
		}
		#endregion
	}

	/// <summary>
	///  A nice wholesome struct
	/// </summary>
	public class Wholesome : Empty, IBabelModel
	{
		/// <summary>
		/// Default constructor
		/// </summary>
		public Wholesome()
		{ 
			MyBOOL = true;
			MyBYTE = 8;
			MyINT8 = -8;
			MyINT16 = 16;
			MyINT32 = 32;
			MyINT64 = 64;
			MyFLOAT32 = (float)-32.32;
			MyFLOAT64 = 64.64;
			MySTRING = BabelRpc.Demo.Strings.STRING;
			MyCHAR = BabelRpc.Demo.Strings.CHAR;
			Names = new List<string>();
			Jokes = new List<Joke>();
			Pokes = new Dictionary<string,Joke>();
			Argh = new List<Dictionary<string,List<Joke>>>();
		}

		/// <summary>
		///  Doc Comment for my null
		/// </summary>
		public int? MyNULL { get; set; }

		/// <summary>
		///  Doc Comment for my bool
		/// </summary>
		public bool? MyBOOL { get; set; }

		/// <summary>
		///  Doc Comment for my byte
		/// </summary>
		public byte? MyBYTE { get; set; }

		/// <summary>
		///  Doc Comment for my int8
		/// </summary>
		public sbyte? MyINT8 { get; set; }

		/// <summary>
		///  Doc Comment for my int16
		/// </summary>
		public short? MyINT16 { get; set; }

		/// <summary>
		///  Doc Comment for my int32
		/// </summary>
		public int? MyINT32 { get; set; }

		/// <summary>
		///  Doc Comment for my int64
		/// </summary>
		public long? MyINT64 { get; set; }

		/// <summary>
		///  Doc Comment for my float32
		/// </summary>
		public float? MyFLOAT32 { get; set; }

		/// <summary>
		///  Doc Comment for my float64
		/// </summary>
		public double? MyFLOAT64 { get; set; }

		/// <summary>
		///  Doc Comment for my null 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required]
		public int? MyNULL2 { get; set; }

		/// <summary>
		///  Doc Comment for my string
		/// </summary>
		public string MySTRING { get; set; }

		/// <summary>
		///  Doc Comment for my datetime
		/// </summary>
		public DateTime? MyDATETIME { get; set; }

		/// <summary>
		///  Doc Comment for my decimal
		/// </summary>
		public decimal? MyDECIMAL { get; set; }

		/// <summary>
		///  Doc Comment for my char
		/// </summary>
		public char? MyCHAR { get; set; }

		/// <summary>
		///  Doc Comment for my binary
		/// </summary>
		public byte[] MyBINARY { get; set; }

		/// <summary>
		///  Doc Comment for my Joke
		/// </summary>
		public Joke MyJOKE { get; set; }

		/// <summary>
		///  Doc Comment for my null Joke
		/// </summary>
		public Joke MyNullJOKE { get; set; }

		/// <summary>
		///  List of names
		/// </summary>
		public List<string> Names { get; set; }

		/// <summary>
		///  List of jokes
		/// </summary>
		public List<Joke> Jokes { get; set; }

		/// <summary>
		///  Make of names to jokes
		/// </summary>
		public Dictionary<string,Joke> Pokes { get; set; }

		/// <summary>
		///  Let's see if we can break something
		/// </summary>
		public List<Dictionary<string,List<Joke>>> Argh { get; set; }

		public override string ToString()
		{
			var ser = new BabelJsonSerializer();
			using(var strm = (System.IO.MemoryStream)ser.Serialize(this))
			{
				return (new UTF8Encoding(false)).GetString(strm.ToArray());
			}
		}
		#region IBabelModel
		public override void RunOnChildren<T>(BabelModelAction<T> method, T auxData, bool runOnAll = true)
		{
			if(method == null) throw new ArgumentNullException("method");
			if(runOnAll) MyNULL = (int?) method("myNULL", typeof(int?), MyNULL, auxData);
			if(runOnAll) MyBOOL = (bool?) method("myBOOL", typeof(bool?), MyBOOL, auxData);
			if(runOnAll) MyBYTE = (byte?) method("myBYTE", typeof(byte?), MyBYTE, auxData);
			if(runOnAll) MyINT8 = (sbyte?) method("myINT8", typeof(sbyte?), MyINT8, auxData);
			if(runOnAll) MyINT16 = (short?) method("myINT16", typeof(short?), MyINT16, auxData);
			if(runOnAll) MyINT32 = (int?) method("myINT32", typeof(int?), MyINT32, auxData);
			if(runOnAll) MyINT64 = (long?) method("myINT64", typeof(long?), MyINT64, auxData);
			if(runOnAll) MyFLOAT32 = (float?) method("myFLOAT32", typeof(float?), MyFLOAT32, auxData);
			if(runOnAll) MyFLOAT64 = (double?) method("myFLOAT64", typeof(double?), MyFLOAT64, auxData);
			if(runOnAll) MyNULL2 = (int?) method("myNULL2", typeof(int?), MyNULL2, auxData);
			if(runOnAll) MySTRING = (string) method("mySTRING", typeof(string), MySTRING, auxData);
			if(runOnAll) MyDATETIME = (DateTime?) method("myDATETIME", typeof(DateTime?), MyDATETIME, auxData);
			if(runOnAll) MyDECIMAL = (decimal?) method("myDECIMAL", typeof(decimal?), MyDECIMAL, auxData);
			if(runOnAll) MyCHAR = (char?) method("myCHAR", typeof(char?), MyCHAR, auxData);
			if(runOnAll) MyBINARY = (byte[]) method("myBINARY", typeof(byte[]), MyBINARY, auxData);
			MyJOKE = (Joke) method("myJOKE", typeof(Joke), MyJOKE, auxData);
			MyNullJOKE = (Joke) method("myNullJOKE", typeof(Joke), MyNullJOKE, auxData);
			Names = (List<string>) method("Names", typeof(List<string>), Names, auxData);
			Jokes = (List<Joke>) method("Jokes", typeof(List<Joke>), Jokes, auxData);
			Pokes = (Dictionary<string,Joke>) method("Pokes", typeof(Dictionary<string,Joke>), Pokes, auxData);
			Argh = (List<Dictionary<string,List<Joke>>>) method("Argh", typeof(List<Dictionary<string,List<Joke>>>), Argh, auxData);

			base.RunOnChildren<T>(method, auxData, runOnAll);
		}

		public override bool RunOnChild<T>(string name, BabelModelAction<T> method, T auxData)
		{
			if(method == null) throw new ArgumentNullException("method");
			switch(name)
			{
				case "myNULL": MyNULL = (int?) method("myNULL", typeof(int?), MyNULL, auxData); return true;
				case "myBOOL": MyBOOL = (bool?) method("myBOOL", typeof(bool?), MyBOOL, auxData); return true;
				case "myBYTE": MyBYTE = (byte?) method("myBYTE", typeof(byte?), MyBYTE, auxData); return true;
				case "myINT8": MyINT8 = (sbyte?) method("myINT8", typeof(sbyte?), MyINT8, auxData); return true;
				case "myINT16": MyINT16 = (short?) method("myINT16", typeof(short?), MyINT16, auxData); return true;
				case "myINT32": MyINT32 = (int?) method("myINT32", typeof(int?), MyINT32, auxData); return true;
				case "myINT64": MyINT64 = (long?) method("myINT64", typeof(long?), MyINT64, auxData); return true;
				case "myFLOAT32": MyFLOAT32 = (float?) method("myFLOAT32", typeof(float?), MyFLOAT32, auxData); return true;
				case "myFLOAT64": MyFLOAT64 = (double?) method("myFLOAT64", typeof(double?), MyFLOAT64, auxData); return true;
				case "myNULL2": MyNULL2 = (int?) method("myNULL2", typeof(int?), MyNULL2, auxData); return true;
				case "mySTRING": MySTRING = (string) method("mySTRING", typeof(string), MySTRING, auxData); return true;
				case "myDATETIME": MyDATETIME = (DateTime?) method("myDATETIME", typeof(DateTime?), MyDATETIME, auxData); return true;
				case "myDECIMAL": MyDECIMAL = (decimal?) method("myDECIMAL", typeof(decimal?), MyDECIMAL, auxData); return true;
				case "myCHAR": MyCHAR = (char?) method("myCHAR", typeof(char?), MyCHAR, auxData); return true;
				case "myBINARY": MyBINARY = (byte[]) method("myBINARY", typeof(byte[]), MyBINARY, auxData); return true;
				case "myJOKE": MyJOKE = (Joke) method("myJOKE", typeof(Joke), MyJOKE, auxData); return true;
				case "myNullJOKE": MyNullJOKE = (Joke) method("myNullJOKE", typeof(Joke), MyNullJOKE, auxData); return true;
				case "Names": Names = (List<string>) method("Names", typeof(List<string>), Names, auxData); return true;
				case "Jokes": Jokes = (List<Joke>) method("Jokes", typeof(List<Joke>), Jokes, auxData); return true;
				case "Pokes": Pokes = (Dictionary<string,Joke>) method("Pokes", typeof(Dictionary<string,Joke>), Pokes, auxData); return true;
				case "Argh": Argh = (List<Dictionary<string,List<Joke>>>) method("Argh", typeof(List<Dictionary<string,List<Joke>>>), Argh, auxData); return true;
				default: return base.RunOnChild<T>(name, method, auxData);
			}
		}
		#endregion
	}

	/// <summary>
	///  Struct to test an initialized value
	/// </summary>
	public class DefaultTest : IBabelModel
	{
		/// <summary>
		/// Default constructor
		/// </summary>
		public DefaultTest()
		{ 
			X = 32;
		}

		public int? X { get; set; }

		public override string ToString()
		{
			var ser = new BabelJsonSerializer();
			using(var strm = (System.IO.MemoryStream)ser.Serialize(this))
			{
				return (new UTF8Encoding(false)).GetString(strm.ToArray());
			}
		}
		#region IBabelModel
		public virtual void RunOnChildren<T>(BabelModelAction<T> method, T auxData, bool runOnAll = true)
		{
			if(method == null) throw new ArgumentNullException("method");
			if(runOnAll) X = (int?) method("X", typeof(int?), X, auxData);

		}

		public virtual bool RunOnChild<T>(string name, BabelModelAction<T> method, T auxData)
		{
			if(method == null) throw new ArgumentNullException("method");
			switch(name)
			{
				case "X": X = (int?) method("X", typeof(int?), X, auxData); return true;
				default: return false;
			}
		}
		#endregion
	}

} 
